```c
#include
```

#c
# main 함수

c언어 중괄호로 묶어줄 경우 이를 코드 블록이라 한다

리턴 값이 없는 main을 사용해도 되나, ANCI 표준은 int main()

문장의 끝 세미콜론(;)

한 문장을 종료해 주는 역할

반드시 넣어 줘야 한다.

가독성이 떨어지기 떄문에 ;을 쓸때마다 줄넘김

블록의 지정 중괄호 {}


# 자료형
#c #자료형


## 주석과 함수
#c #주석 #함수 

### 주석 - 사람만 알아볼 수 있도록 적은 설명

→ 컴파일러가 처리하지 않아 프로그램에는 영향을 주지않는다

\\한 줄 주석

\\*
여러 줄

주석*\

설명할 때 사용


### 함수 - 어떤 작업을 수행하는 코드 / 재사용성을 높여준다
#c #함수

### 전 처리기
#c #전처리기 

전 처리기 컴파일러가 프로그램을 번역하기 전 처리하는 프로그램

→ 모든 전 처리기는 \#로 시작한다

주요 전 처리기 지시자 - \#include, \#define

\#include

파일 포함 지시자

헤더 파일 (header.file) <.h>, “.h”

코드 맨위에 존재하고 있으며, 개발자가 쉽게 코딩을 할 수 있도록 함수나 클래스를 미리 지정해놓은 파일을 의미

<>: 보통 표준 라이브러리 포함할떄 사용한다

“” : 현재 소스파일을 기준으로 헤더파일 포함.

만일 찾지 못하면 컴파일 옵션의 지정된 헤더파일 경로에서 찾는다

ex) “message.h”, “./message.h”, “./header/message.h”

stdio.h : Stardard I/O 라이브러리의 헤더파일
```
#define
```
다른 문자열로 대치될 단어 (매크로 macro)를 정의함

마지막에 ;을 붙이지 않는다


### 상수
#c #상수 

38, 75, 63과 같은 데이터를 직접 표현하거나 저장할 수 있음


## 변수
#c #변수

값을 저장하는 메모리 공간

모든 프로그래밍의 핵심 요소

2차 방정식 a^2 + b^2 = c^2의 변수 a, b, c 와 같은 의미

변수에 저장되는 값은 변경 가능

### 변수 선언과 쓰임

C변수에 저장하는 값의 종류와 저장되는 범위(크기)에 따라 변수를 다르게 사용해야 하는데, 처음 변수를 지정하는 것

반드시 변수를 사용하기 전에 선언 해야함

### 변수 선언 규칙

변수 이름은 알파벳, 숫자 언더바(_)로 구성된다

대소문자를 구분한다.(Num과 num는 다른 변수이다.)

숫자로 시작할 수 없고 키워드도 사용할 수 없다

이름 사이에 공백이 삽입될 수 없다

### 변수의 초기화

변수 선언 과정에서 변수의 초기값을 저장할 수 있음

쉼표(,)를 사용하여 동일한 자료형의 여러 변수를 하나의 선언문에서 선언하고 초기화 할 수 있음

#c #자료형 #기타
## 기타 자료형

### 비트(bit)와 바이트(byte)

컴퓨터의 모든 데이터는 2진수

1 비트(bit) = 컴퓨터의 최소단위 0 또는 1을 표시

1바이트(byte) = 8비트(bit), 1문자(영문자) = 1바이트 (byte)

사이즈 구하기 : sizeof(자료형)

unsigned : 0과 양수 만을 표현한다

### 숫자의 범위

int형이 4byte(32bit) → 2^-31 ~ 2^31 -1 (singed인 경우)

→ 자료형의 크기로 인해 논리적 오류 발생할 수 있다

기타 자료형

→ void

### 아스키 코드

미국 표준 협회에 의해 정의된 코드

컴퓨터는 0과1 이진수로 이루어져 있기 때문에 문자를 표현하기 위한 표준 코드

문자와 숫자의 연결 관계를 정의

ASCII 코드의 범위는 0이상 127이하

# scanf()

키보드로부터의 데이터 입력

데이터 입력 시, 데이터를 구분하는 기준은 공백

입력의 끝에는 반드시 엔터 키를 입력해 마무리

 
# 조건문
#c #조건문 

2줄 이상일땐 블록으로 묶어 줘야한


## if 조건문
#c #조건문 #if 

조건을 만족하면(TRUE이면) 특정 명령을 실행하고, 조건을 만족하지 않으면 아무 명령도 실행하지 않는 프로그램의 흐름

```c
if (조건){
	조건이 참일 경우 실행
}
else {
	조건이 거짓일 경우 실행
}
```

## &&연산자의 이용
#c #조건문 #연산자 #and

모든 조건이 참일 경우에만 참이 되는 연산

```c
if (score1 >= 60 && score2 >= 60)
	printf("합격\\n");
else
	printf("불합격\\n");
```


## 조건 연산자
#c #조건문 #연산자 #삼항연산자

경우에 따라서 if~else문을 대신하여 사용할 수 있는 연산자

‘상 향 연산자’라고도 불린다

기호 ? 와 : 로 구성

피연산자는 ‘조건’, A 그리고 B

문장에 따라서 조건 연산자는 if~else문 보다 간결한 표현 가능

```c
printf(num>0 ? "true" : "false")
```

### switch문
#c #조건문 #switch

조건에 따라 해당 레이블로 이동하여 실행을 계속하는 제어문

실행 위치에 대한 표시는 case와 default 레이블 사용

레이블에 사용되는 숫자나 switch문에 전달되는 값 모두 정수이어야 한다

## 스코프와 지역변수
#c #지역변수

```c
#include <stdio.h>

int main(void)
{
	int num = 1;
	if (num == 1) {
		int num = 2;
		num++;
		printf("...%d", num);
	}
	else {
		num++;
		printf("... %d..", num);
	}
	printf("...%d...", num);
	
}
```

스코프와 지역 변수

중괄호 내에 선언이 되는 변수를 가리켜 지역변수라 한다

지역변수는 선언된 중괄호를 벗어나면 메모리 공간에서 소멸된

## while() 반복문
#c #조건문 #반복문 while문

while(조건)문은 조건이 참일때까지 계속 반복 실행한다

while문은 주어진 ‘반복의 조건’이 ‘참’인 동안 ‘반복의 영역’을 반복 실행

반복의 영역이 둘 이상의 문장으로 구성되면, 중괄호로 묶는다.

while은 조건이 거짓이면 한 번도 실행되지 않을 수 있다

### 무한루프

while문의 반복조건으로 1이오면 반복조건은 항상 참이 되어 무한루프를 형성(1은 논리적으로 참)

무한루프도 소프트웨어 개발에서 흔히 사용되는 기술

```c
int main(void){
	int i=0;
	
	while(1);
	{
		printf("%d 번째 Hello World \\n", i+1);
		i++
		}
	return 0;
}
```

## do while() 반복문
#c #조건문 #반복문 do while문

do~while의 특징

while문과 달리 조건검사를 뒷부분에서 진행

때문에 while문과 달리 조건에 상관없이 반복영역을 최소 1회 실행

```c
int main(void)
{
	int i = 1;
	int dan;
	
	printf("몇 단의 출력을 원하는가? ");
	scanf("%d", %dan)
	do
	{
	printf("%d x %d = %d\\n",dan,i,dan*1)
	i++
	}while(i<10);
	return 0;
}
```

뒤에있는 while에 세미콜론을 붙여야 한다.

## for문
#c #조건문 #반복문 for문

while문처럼 반복문으로서 원리는 같지만 펴햔 방법이 다름.

조건 식을 포함하여 초기 식(시작 값), 증감 식 등 2가지를 더 넣을 수 있음

반복문을 사용하는 목적 중 하나

정해진 횟수만큼 반복 실행하기 위함

반복문의 기본 구성 3요소

반복 횟수를 세기 위한 변수

반복문의 탈출 조건

탈출 조건 성립을 위한 연산

while문은 기본 구성 3요소가 뿔뿔이 흩어져있다(반복 횟수의 확인이 불편)

for문은 기본 구성 3요소가 한 줄에 나열되어있다.(for문의 장점)

for문과 while문은 상호 변경이 가능

break 와 continue

```c
#include <stdio.h>

main()
{
	int num;
	while(1)
	{
		printf("%d" &num);
		scanf("%d", &num);
		if (num < 0) break;
		if (num == 0) continue;
		if (num % 2 == 1)
			printf("홀수\\n");
	}
	else
		printf("짝수\\n");
}
```

break문은 switch문과 각종 반복문을 빠져나가는데 사용 됨

continue 문은 반복문의 나머지 검사를 허용하고 다음 검사를 빠져나간다

# 배열
#c #배열

배열 사용하기

```c
#include <stdio.h>
int main(void){
	int score[10] = {1,2,3,4,5,6,7,8,9,10};
	for (int i = 0; i<=10; i++){
		printf("%d", score[0]);
	}
}
```

같은 종류의 여러개 데이터를 처리하기 쉽게 나열한 것

정수형, 문자형 등 같은 자료형에 배열 이름을 지정하여 선언

배열의 길이와 동일한 개수의 초기화 리스트 존재

가장 일반적인 초기화 방식

초기화 리스트에 나열된 값은 배열에 순서대로 저장

```c
#include <stdio.h>

int main(void)
{
	int i;
	int arr1[5] = { 1, 2, 3, 4 ,5 };
	int len0fArr1 = sizeof(arr1) / sizeof(int);

	//int lenOfArr1 = size(arr1)/sizeof(arr[0]);
	printf("arr1[5] = {1, 2, 3, 4, 5}의 ~~ \\n");
	for (i = 0; i < len0fArr1; i++) {
		printf("%d번째 요소 ~~ : %d\\n", i + 1, arr1[i]);
	}
	printf("\\n");
	return 0;
}
```

배열의 길이를 나타내는 값이 빠져있는 경우

컴파일러가 초기화 리스트의 수를 참조하여 배열의 길이를 결정

초기화 리스트의 수가 배열의 길이보다 작은 경우

초기화 리스트의 수가 배열의 길이보다 작으면, 나머지 부분은 0으로 초기화

## 문자열 배열
#c #문자열

```c
#include <stdio.h>

int main(void)
{
	char string1[6] = { 'H','e','l','l','o','\0' };
	char string2[6] = "world";
	printf("%s\\n", string1);
	printf("%s\\n", string2);
	printf("%s %s\\n", string1, string2);
	return 0;
}
```

배열로 문자열을 저장하고 처리하기 위해서는 마지막에 문자열의 마지막임을 나타내는 문자 \0을 반드시 넣어 주어야함

널 문자 : C언어에서 문자열의 끝을 나타내는 기호로 사용

5행에서 큰따옴표를 이용하여 문자배열을 초기화하며, 마지막에 자동으로 널 문자 추가

6행에서 printf()함수는 %s형태로 출력

널 문자가 나올 떄까지 문자를 계속 출력

널 문자는 \0,0,null 등으로 표현

6~8행에서 문자열 배열 string, string에 저장되어 있는 문자열을 서식지정자 %s를 이용하여 출력

문자 1개를 나타내는 서식지정자 %c를 이용하여 출력하는 방법도 가능

```c
for(i=0; stirng1[i] != NULL; i++)
	printf("%c", string1[i]);
```

널 문자의 존재와 표현에 대한 이해

```c
int main(void)
{
	printf("AA0BB0CC");
	printf("|");
	printf("AA\\0BB\\0CC");
	printf("|");
	printf("\\0AA");
	printf("|");
}
```

## 배열의 주소
#c #배열주소

scanf 함수로 문자열을 입력 받기 위해 필요한 두 가지 사항

문자열을 저장할 char형 배열

문자열의 입력을 의미하는 서식문자 %s

문자열을 입력 받기 위한 scanf 함수 호출문 구성

배열의 이름은 그자체가 배열의 시작 주소를 의미하는 상수

따라서 배열의 이름을 인자로 전달하면 &연산자를 붙이지 않는다.

scanf 함수는 데이터를 공백으로 구분하므로, 공백을 포함하는 문자열의 입력은 불가능!
## 2차원 배열
#c #2차원 #배열
- 배열의 메모리 공간 할당
```c
int main(void){
	int arr1[4];
	int arr2[4];
	int arr3[5];
	int arr[3][4];
}
```
```c
int main(void){
	int arr[3][4];
	printf("배열의 시작주소: %d \n", arr);
	printf("1행의 시작주소: %d \n", arr[0]);
	printf("2행의 시작주소: %d \n", arr[1]);
	printf("3행의 시작주소: %d \n", arr[2]);
}
```
## 2차원 배열 각 행의 위치 정보
### 실행결과를 통해 확인 가능한 사실
- 2차원 배열도 메모리 공간에서는 1차원의 구조를 가짐
- arr\[0], arr\[1], arr\[2]는 배열 각 행의 시작 주소를 의미하므로 값이 16씩 차이가 난다.

###
- arr이 2차원 배열일 때, arr과 arr\[0]이 의미하는 주소 값 동일
- arr은 배열 전체를 의미하고, arr\[0]은 2차원 배열의 첫 번째 행을 의미 함
- 이는 sizeof 연산의 결과로 표현됨
```c
int main(void){
	int arr[3][4];
	printf("sizeof(arr): %d \n", sizeof(arr)); //48
	printf("sizeof(arr[0]): %d \n", sizeof(arr[0])); //16
	printf("sizeof(arr[1]): %d \n", sizeof(arr[1])); //16
	printf("sizeof(arr[2]): %d \n", sizeof(arr[2])); //16
	return 0;
}
```
## 2차원 배열의 초기화
#c #2차원 #배열 #초기화
### 초기화 리스트의 수가 배열의 길이보다 작은 경우
- ### 중괄호를 하나만 사용하면 순서대로 값이 채워짐
- ### 1행이 먼저 채워지고, 그 다음에 2행이 채워짐
- ### 배열 요소의 개수보다 초기화 리스트의 개수가 적다면 나머지 부분은 0으로 채워짐
### 배열의 길이 정보가 빠져있는 경우(1차원 배열)
- ### 컴파일러가 초기화 리스트의 수를 참조하여 배열의 길이를 결정
### 배열의 세로 길이 정보가 빠져있는 경우
- ### 컴파일러가 초기화 리스트의 수를 참조하여 배열의 길이를 결정
### 2차원 배열에 값 넣기
```c
int arr[2][3];
arr[2] = 52;
arr[0][0] = 0;
arr[0][1] = 1;
...
arr[1][2] = 5;
printf("%d\n", arr[0][0])
printf("%d\n", arr[0][1])
...
printf("%d\n", arr[1][2])
```
### → 반복문을 사용하여 각각 값을 넣고, 또 출력도 해보자
```c
#include <stdio.h>

int main(void){
	int arr[2][3];
	int k = 0;
	for(int i = 0; i < 2; i++){
		for(int j = 0; j<3; j++){
		arr[i][j] = k;
		k++;
		printf("arr[%d][%d] : %d\n", i, j, arr[i][j]);
		}
	}
}
```
